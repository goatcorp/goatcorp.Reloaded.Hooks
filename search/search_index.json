{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project Reloaded: Hooking WTF You can unit test function hooks!? Introduction Reloaded.Hooks is a library for intercepting and modifying existing binary functions on x86 and x64 machines. It is most often used to either intercept Win32 API calls (e.g. NtCreateFile to find out what files the current process is loading) or to patch existing functions within a program; e.g. patching software at runtime. If this concept is unfamiliar to you; I would suggest to research the term Hooking while reading the documentation. Reloaded.Hooks is a managed alternative to native libraries such as MinHook and Detours , targeted at tackling more advanced/difficult use cases; such as when functions do not use standard calling conventions . Feature Highlights Support for x86 and x64 architectures. Call & hook unmanaged functions with custom calling conventions . Stack function hooks. You can hook already hooked functions as many times as you like. Mid function x86/x64 assembly hooks; similar to the likes of Cheat Engine . Highly compatible. Detects & patches common variations of existing function hooks when hooking. Hook functions hooked by other libraries; this feature is unique to Reloaded.Hooks. Generate native wrapper functions for converting between custom calling conventions. e.g. Stdcall to Fastcall converter. Many lower level utility functions allowing you to deal with things like Virtual Function Tables . Contributions As with the standard for all of the Reloaded-Project , repositories; contributions are very welcome and encouraged. Feel free to implement new features, make bug fixes or suggestions so long as they are accompanied by an issue with a clear description of the pull request. If you are implementing new features, please do provide the appropriate unit tests to cover the new features you have implemented; try to keep the coverage high \ud83d\ude0a. Authors & Contributions Reloaded.Hooks uses the Flat Assembler (FASM) by Tomasz Grysztar. Reloaded.Hooks uses the Iced library by 0xd4d. Legacy Older versions of Reloaded.Hooks used the SharpDisasm library by Justin Stenning (spazzarama) , a partial port of Udis86 by Vivek Thampi . Both of these libraries are originally distributed under the under the 2-clause \"Simplified BSD License\".","title":"Home"},{"location":"#introduction","text":"Reloaded.Hooks is a library for intercepting and modifying existing binary functions on x86 and x64 machines. It is most often used to either intercept Win32 API calls (e.g. NtCreateFile to find out what files the current process is loading) or to patch existing functions within a program; e.g. patching software at runtime. If this concept is unfamiliar to you; I would suggest to research the term Hooking while reading the documentation. Reloaded.Hooks is a managed alternative to native libraries such as MinHook and Detours , targeted at tackling more advanced/difficult use cases; such as when functions do not use standard calling conventions .","title":"Introduction"},{"location":"#feature-highlights","text":"Support for x86 and x64 architectures. Call & hook unmanaged functions with custom calling conventions . Stack function hooks. You can hook already hooked functions as many times as you like. Mid function x86/x64 assembly hooks; similar to the likes of Cheat Engine . Highly compatible. Detects & patches common variations of existing function hooks when hooking. Hook functions hooked by other libraries; this feature is unique to Reloaded.Hooks. Generate native wrapper functions for converting between custom calling conventions. e.g. Stdcall to Fastcall converter. Many lower level utility functions allowing you to deal with things like Virtual Function Tables .","title":"Feature Highlights"},{"location":"#contributions","text":"As with the standard for all of the Reloaded-Project , repositories; contributions are very welcome and encouraged. Feel free to implement new features, make bug fixes or suggestions so long as they are accompanied by an issue with a clear description of the pull request. If you are implementing new features, please do provide the appropriate unit tests to cover the new features you have implemented; try to keep the coverage high \ud83d\ude0a.","title":"Contributions"},{"location":"#authors-contributions","text":"Reloaded.Hooks uses the Flat Assembler (FASM) by Tomasz Grysztar. Reloaded.Hooks uses the Iced library by 0xd4d.","title":"Authors &amp; Contributions"},{"location":"#legacy","text":"Older versions of Reloaded.Hooks used the SharpDisasm library by Justin Stenning (spazzarama) , a partial port of Udis86 by Vivek Thampi . Both of these libraries are originally distributed under the under the 2-clause \"Simplified BSD License\".","title":"Legacy"},{"location":"AssemblyHooks/","text":"Assembly Hooks For advanced users requiring very specialized uses (e.g. Mid Function Hooks), a Cheat-Engine like pure assembly code hook is available. This hook replaces the original application code with a jump to your own custom supplied code and (optionally) the original code in either of the three combinations: Discard Original Code Execute Custom Code First Execute Custom Code Last An Example Consider the following function. // Returns the value of `a + b` [UnmanagedFunctionPointer(CallingConvention.Cdecl)] public delegate int AddFunction ( int a , int b ); In native assembly, this function can be represented by something like the following: // Unoptimized code, for demonstration only. push _ebp, mov _ebp, _esp, mov _eax, [_ebp + wordSize * 2], // Left Parameter mov _ecx, [_ebp + wordSize * 3], // Right Parameter add _eax, _ecx, pop _ebp, ret Macros: (wordSize = 4 on x86, wordSize = 8 on x64), (_ebp is ebp on x86, _ebp is rbp on x64), etc. This function could, for example be manipulated to return result + 1 , in any of the following ways. Discarding Original Code Straight up replace the original code with your own. int wordSize = IntPtr . Size ; string [] addFunction = { $\"{_use32}\" , $\"push {_ebp}\" , $\"mov {_ebp}, {_esp}\" , $\"mov {_eax}, [{_ebp} + {wordSize * 2}]\" , // Left Parameter $\"mov {_ecx}, [{_ebp} + {wordSize * 3}]\" , // Right Parameter $\"add {_eax}, 1\" , // Left Parameter }; _addNoOriginalHook = new AsmHook ( addFunction , addressOfNativeCode , AsmHookBehaviour . DoNotExecuteOriginal ). Activate (); Executing Original Code First string [] addFunction = { $\"{_use32}\" , $\"add {_eax}, 1\" , // Left Parameter - Should have already been copied from stack. }; _addAfterOriginalHook = new AsmHook ( addFunction , addressOfNativeCode , AsmHookBehaviour . ExecuteAfter ). Activate (); Executing Original Code Last int wordSize = IntPtr . Size ; string [] addFunction = { $\"{_use32}\" , $\"add [{_esp} + {wordSize * 1}], byte 1\" , // Add 1 to left parameter on stack. }; _addBeforeOriginalHook = new AsmHook ( addFunction , addressOfNativeCode , AsmHookBehaviour . ExecuteFirst ). Activate (); What's \"Original Code\" ? Answer: The minimal amount of x86/64 assembly instructions required to use 7 or more bytes. Understanding how this hook works helps a bit. Essentially what this hook does is place a jmp instruction at the location supplied as the addressOfNativeCode to your asm code. However, as the jump to your code overwrites the original code, something has to be done with that original code. What this hook does is it calculates the minimal amount of assembly instructions (starting from addressOfNativeCode ) necessary to free up space for the jmp instruction. That is the minimal amount of instructions that uses >= 7 bytes of space. Those instructions are referred to as the \"original code\". Depending on your preference, this code is either discarded or inserted before/after your own code. In other words; before you use this hook, you have to look at your disassembly and determine the minimum amount of instructions what take >- 7 bytes. When Reloaded.Hooks does its work; that will be the \"original code\". As such, this hook is reserved for advanced users. (Note: A bit more actually happens under the hood to enable the Disable/Enable toggle, but this is the simple version).","title":"Assembly Hooks (Advanced)"},{"location":"AssemblyHooks/#assembly-hooks","text":"For advanced users requiring very specialized uses (e.g. Mid Function Hooks), a Cheat-Engine like pure assembly code hook is available. This hook replaces the original application code with a jump to your own custom supplied code and (optionally) the original code in either of the three combinations: Discard Original Code Execute Custom Code First Execute Custom Code Last","title":"Assembly Hooks"},{"location":"AssemblyHooks/#an-example","text":"Consider the following function. // Returns the value of `a + b` [UnmanagedFunctionPointer(CallingConvention.Cdecl)] public delegate int AddFunction ( int a , int b ); In native assembly, this function can be represented by something like the following: // Unoptimized code, for demonstration only. push _ebp, mov _ebp, _esp, mov _eax, [_ebp + wordSize * 2], // Left Parameter mov _ecx, [_ebp + wordSize * 3], // Right Parameter add _eax, _ecx, pop _ebp, ret Macros: (wordSize = 4 on x86, wordSize = 8 on x64), (_ebp is ebp on x86, _ebp is rbp on x64), etc. This function could, for example be manipulated to return result + 1 , in any of the following ways.","title":"An Example"},{"location":"AssemblyHooks/#discarding-original-code","text":"Straight up replace the original code with your own. int wordSize = IntPtr . Size ; string [] addFunction = { $\"{_use32}\" , $\"push {_ebp}\" , $\"mov {_ebp}, {_esp}\" , $\"mov {_eax}, [{_ebp} + {wordSize * 2}]\" , // Left Parameter $\"mov {_ecx}, [{_ebp} + {wordSize * 3}]\" , // Right Parameter $\"add {_eax}, 1\" , // Left Parameter }; _addNoOriginalHook = new AsmHook ( addFunction , addressOfNativeCode , AsmHookBehaviour . DoNotExecuteOriginal ). Activate ();","title":"Discarding Original Code"},{"location":"AssemblyHooks/#executing-original-code-first","text":"string [] addFunction = { $\"{_use32}\" , $\"add {_eax}, 1\" , // Left Parameter - Should have already been copied from stack. }; _addAfterOriginalHook = new AsmHook ( addFunction , addressOfNativeCode , AsmHookBehaviour . ExecuteAfter ). Activate ();","title":"Executing Original Code First"},{"location":"AssemblyHooks/#executing-original-code-last","text":"int wordSize = IntPtr . Size ; string [] addFunction = { $\"{_use32}\" , $\"add [{_esp} + {wordSize * 1}], byte 1\" , // Add 1 to left parameter on stack. }; _addBeforeOriginalHook = new AsmHook ( addFunction , addressOfNativeCode , AsmHookBehaviour . ExecuteFirst ). Activate ();","title":"Executing Original Code Last"},{"location":"AssemblyHooks/#whats-original-code","text":"Answer: The minimal amount of x86/64 assembly instructions required to use 7 or more bytes. Understanding how this hook works helps a bit. Essentially what this hook does is place a jmp instruction at the location supplied as the addressOfNativeCode to your asm code. However, as the jump to your code overwrites the original code, something has to be done with that original code. What this hook does is it calculates the minimal amount of assembly instructions (starting from addressOfNativeCode ) necessary to free up space for the jmp instruction. That is the minimal amount of instructions that uses >= 7 bytes of space. Those instructions are referred to as the \"original code\". Depending on your preference, this code is either discarded or inserted before/after your own code. In other words; before you use this hook, you have to look at your disassembly and determine the minimum amount of instructions what take >- 7 bytes. When Reloaded.Hooks does its work; that will be the \"original code\". As such, this hook is reserved for advanced users. (Note: A bit more actually happens under the hood to enable the Disable/Enable toggle, but this is the simple version).","title":"What's \"Original Code\" ?"},{"location":"Benchmarks/","text":"Benchmarks Sample benchmarks of function hooks. Hardware BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-4790K CPU 4.00GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 5.0.200-preview.20601.7 [Host] : .NET Core 5.0.1 (CoreCLR 5.0.120.57516, CoreFX 5.0.120.57516), X64 RyuJIT Job-EJHKEF : .NET Core 5.0.1 (CoreCLR 5.0.120.57516, CoreFX 5.0.120.57516), X64 RyuJIT Platform = X64 Toolchain=64 bit cli Benchmarked Methods The benchmark measures the time taken to execute the following function 1 million ( 1,000,000 ) times: static int Add(int a, int b) { return a + b; } | Method | Description |------------------- | ----------- | ManagedInlined | Execute an inlined version of the code. | Managed | Execute a non-inlined version of the code. | ManagedUnoptimized | Execute an unoptimized version of the code. (Calling Convention Compliant) | NoHookPointer | Execute a native assembly version of the code using C#9 function pointers (calli) | NoHookDelegate | Execute a native assembly version of the code using Delegates (Marshal.GetDelegateForFunctionPointer) | DelegateHook | Execute a hooked version using delegates. | FuncPtrHook | Execute a hooked version using function pointers. ManagedInlined stack: .net (function) Managed stack: .net (implementation) .net (function) ManagedUnoptimized stack: .net (implementation, calling convention compliant) .net (function) NoHookPointer stack: native (via function pointer) .net to native transition .net (function) NoHookDelegate stack: native (via function pointer) .net to native transition .net delegate code .net (function) DelegateHook stack: native .net to native transition .net delegate code .net (hook function) .net delegate code native to .net transition native .net to native transition .net delegate code .net (function) FuncPtrHook stack: native .net to native transition .net (hook function) native to .net transition native .net to native transition .net (function) X86 Benchmarks | Method | Mean | Error | StdDev | |------------------- |------------:|----------:|----------:| | ManagedInlined | 448.7 \u03bcs | 2.89 \u03bcs | 2.71 \u03bcs | | Managed | 1,754.0 \u03bcs | 9.40 \u03bcs | 7.34 \u03bcs | | ManagedUnoptimized | 1,992.6 \u03bcs | 20.04 \u03bcs | 17.76 \u03bcs | | NoHookPointer | 2,661.3 \u03bcs | 16.87 \u03bcs | 14.96 \u03bcs | | NoHookDelegate | 10,787.7 \u03bcs | 123.28 \u03bcs | 115.32 \u03bcs | | DelegateHook | 41,242.1 \u03bcs | 226.90 \u03bcs | 201.14 \u03bcs | | FuncPtrHook | 11,825.8 \u03bcs | 54.23 \u03bcs | 48.07 \u03bcs | X64 Benchmarks | Method | Mean | Error | StdDev | |------------------- |------------:|----------:|----------:| | ManagedInlined | 448.6 \u03bcs | 1.90 \u03bcs | 1.78 \u03bcs | | Managed | 1,583.8 \u03bcs | 8.50 \u03bcs | 7.53 \u03bcs | | ManagedUnoptimized | 1,820.4 \u03bcs | 20.18 \u03bcs | 15.75 \u03bcs | | NoHookPointer | 6,958.4 \u03bcs | 20.41 \u03bcs | 17.04 \u03bcs | | NoHookDelegate | 16,784.0 \u03bcs | 111.56 \u03bcs | 104.35 \u03bcs | | DelegateHook | 55,987.3 \u03bcs | 456.96 \u03bcs | 405.08 \u03bcs | | FuncPtrHook | 24,694.2 \u03bcs | 157.92 \u03bcs | 123.29 \u03bcs | Notes A close estimate of the native to .net transition can be calculated with NoHookPointer - ManagedUnoptimized . Calling a function using a delegate is almost as expensive as full function hook using function pointers. If absolute performance is a must (e.g. hooking graphics APIs called 100,000+ times per second), you should probably use native code instead. Some improved performance may be seen in the future based on a possible implementation of CallConvSuppressGCTransition .","title":"Benchmarks"},{"location":"Benchmarks/#benchmarks","text":"Sample benchmarks of function hooks.","title":"Benchmarks"},{"location":"Benchmarks/#hardware","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-4790K CPU 4.00GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 5.0.200-preview.20601.7 [Host] : .NET Core 5.0.1 (CoreCLR 5.0.120.57516, CoreFX 5.0.120.57516), X64 RyuJIT Job-EJHKEF : .NET Core 5.0.1 (CoreCLR 5.0.120.57516, CoreFX 5.0.120.57516), X64 RyuJIT Platform = X64 Toolchain=64 bit cli","title":"Hardware"},{"location":"Benchmarks/#benchmarked-methods","text":"The benchmark measures the time taken to execute the following function 1 million ( 1,000,000 ) times: static int Add(int a, int b) { return a + b; } | Method | Description |------------------- | ----------- | ManagedInlined | Execute an inlined version of the code. | Managed | Execute a non-inlined version of the code. | ManagedUnoptimized | Execute an unoptimized version of the code. (Calling Convention Compliant) | NoHookPointer | Execute a native assembly version of the code using C#9 function pointers (calli) | NoHookDelegate | Execute a native assembly version of the code using Delegates (Marshal.GetDelegateForFunctionPointer) | DelegateHook | Execute a hooked version using delegates. | FuncPtrHook | Execute a hooked version using function pointers. ManagedInlined stack: .net (function) Managed stack: .net (implementation) .net (function) ManagedUnoptimized stack: .net (implementation, calling convention compliant) .net (function) NoHookPointer stack: native (via function pointer) .net to native transition .net (function) NoHookDelegate stack: native (via function pointer) .net to native transition .net delegate code .net (function) DelegateHook stack: native .net to native transition .net delegate code .net (hook function) .net delegate code native to .net transition native .net to native transition .net delegate code .net (function) FuncPtrHook stack: native .net to native transition .net (hook function) native to .net transition native .net to native transition .net (function)","title":"Benchmarked Methods"},{"location":"Benchmarks/#x86-benchmarks","text":"| Method | Mean | Error | StdDev | |------------------- |------------:|----------:|----------:| | ManagedInlined | 448.7 \u03bcs | 2.89 \u03bcs | 2.71 \u03bcs | | Managed | 1,754.0 \u03bcs | 9.40 \u03bcs | 7.34 \u03bcs | | ManagedUnoptimized | 1,992.6 \u03bcs | 20.04 \u03bcs | 17.76 \u03bcs | | NoHookPointer | 2,661.3 \u03bcs | 16.87 \u03bcs | 14.96 \u03bcs | | NoHookDelegate | 10,787.7 \u03bcs | 123.28 \u03bcs | 115.32 \u03bcs | | DelegateHook | 41,242.1 \u03bcs | 226.90 \u03bcs | 201.14 \u03bcs | | FuncPtrHook | 11,825.8 \u03bcs | 54.23 \u03bcs | 48.07 \u03bcs |","title":"X86 Benchmarks"},{"location":"Benchmarks/#x64-benchmarks","text":"| Method | Mean | Error | StdDev | |------------------- |------------:|----------:|----------:| | ManagedInlined | 448.6 \u03bcs | 1.90 \u03bcs | 1.78 \u03bcs | | Managed | 1,583.8 \u03bcs | 8.50 \u03bcs | 7.53 \u03bcs | | ManagedUnoptimized | 1,820.4 \u03bcs | 20.18 \u03bcs | 15.75 \u03bcs | | NoHookPointer | 6,958.4 \u03bcs | 20.41 \u03bcs | 17.04 \u03bcs | | NoHookDelegate | 16,784.0 \u03bcs | 111.56 \u03bcs | 104.35 \u03bcs | | DelegateHook | 55,987.3 \u03bcs | 456.96 \u03bcs | 405.08 \u03bcs | | FuncPtrHook | 24,694.2 \u03bcs | 157.92 \u03bcs | 123.29 \u03bcs |","title":"X64 Benchmarks"},{"location":"Benchmarks/#notes","text":"A close estimate of the native to .net transition can be calculated with NoHookPointer - ManagedUnoptimized . Calling a function using a delegate is almost as expensive as full function hook using function pointers. If absolute performance is a must (e.g. hooking graphics APIs called 100,000+ times per second), you should probably use native code instead. Some improved performance may be seen in the future based on a possible implementation of CallConvSuppressGCTransition .","title":"Notes"},{"location":"FunctionPointers/","text":"Function Pointers With the release of .NET 5 and C# 9.0, Reloaded.Hooks also additionally provides support for the usage of function pointers for those interested in maximizing performance. Using function pointers reduces overhead in the native <=> managed transition as we can skip delegates altogether and under the hood, use the efficient calli IL opcode. Outside of the quest of achieving performance however, the usage of function pointers is not recommended. Compromises with Function Pointers Static functions only. No compile-time checking (no compile error if your function doesn't match defined pointer). No marshalling. Do it yourself. e.g. Marshal.StringToHGlobalAnsi and Marshal.FreeHGlobal for ANSI strings. No pointer types/ref/out (limitation of generics). You should use struct wrappers like Reloaded.Memory 's BlittablePointer . Then in your actual UnmanagedCallersOnly function declaration use raw pointers. There is an implicit conversion for BlittablePointer . Documentation: Cannot document parameter types outside of including the info directly in the struct description. Defining Functions As C# currently doesn't support named function pointers, we have to improvise a bit. In order to define a structure, you should define a struct with a single field of type FuncPtr . The generic type arguments to the FuncPtr are the arguments to your function pointer and the return type. // Parameter 1 is `int` // Parameter 2 is `int` // Return type is `int` [Function(CallingConventions.Cdecl)] public struct CalculatorFunction { public FuncPtr < int , int , int > Value ; } You should then be able to use ( CalculatorFunction ) in place of the regular delegate in all common APIs. Note: If no value is returned, consider using Reloaded.Hooks.Definitions.Structs.Void as the return parameter to help readability. Calling Functions Calling functions is the same as with delegates, simply use the Invoke function of the pointer inside your struct. // Alias can be set at the top of the .cs file. private CalculatorFunction _addFunctionPointer ; void makeFunctionPointer () { var addFuncPointer = ReloadedHooks . CreateWrapper < CalculatorFunction >(( long ) _nativeCalculator . Add , out var _ ); var three = addFuncPointer . Value . Invoke ( 1 , 2 ); } Note: There are overloads for common calling conventions InvokeStdcall , InvokeCdecl and InvokeThiscall . Invoke is equivalent to InvokeStdcall . Hooking Functions Hooking functions using poitners requires .NET 5; due to the necessity of using the UnmanagedCallersOnly attribute. /* Hook object. */ private static IHook < CalculatorFunction > _addHook ; // Reloaded.Hooks assumes function pointners are `Stdcall` on Windows (.NET default). // You should therefore use `CallConvStdcall` with your hook functions and use // Invoke/InvokeStdcall for calling the original function. [UnmanagedCallersOnly(CallConvs = new[] { typeof ( CallConvStdcall ) })] static int AddHookFunction ( int a , int b ) => _addHook . OriginalFunction . Value . Invoke ( a , b ) + 1 ; public unsafe void HookAdd () { _addHook = ReloadedHooks . Instance . CreateHook < CalculatorFunction >(( delegate * unmanaged [ Stdcall ]< int , int , int >)& AddHookFunction , ( long ) _nativeCalculator . Add ). Activate (); } For your UnmanagedCallersOnly function please use raw pointers in places of BlittablePointer (where applicable). There is an implicit conversion between the two so no manual conversions will be necessary when calling the original function again. There is currently an issue in the runtime where generics aren't properly checked for blittability with UnmanagedCallersOnly . Hooking via Reflection Experimental : Thorough testing not yet conducted. /* Hook object. */ private static IHook < CalculatorFunction > _addHook ; [UnmanagedCallersOnly(CallConvs = new[] { typeof ( CallConvStdcall ) })] static int AddHookFunction ( int a , int b ) => _addHook . OriginalFunction . Value . Invoke ( a , b ) + 1 ; public unsafe void HookAdd () { _addHook = ReloadedHooks . Instance . CreateHook < CalculatorFunction >( typeof ( ThisClass ), nameof ( AddHookFunction ), ( long ) _nativeCalculator . Add ). Activate (); } Writing the cast to a function pointer can be tedious. As such, Reloaded.Hooks provides overloads which allow you to select a static function via reflection using the containing class and function name. Note: Local functions are not supported.","title":"Function Pointers (C#9)"},{"location":"FunctionPointers/#function-pointers","text":"With the release of .NET 5 and C# 9.0, Reloaded.Hooks also additionally provides support for the usage of function pointers for those interested in maximizing performance. Using function pointers reduces overhead in the native <=> managed transition as we can skip delegates altogether and under the hood, use the efficient calli IL opcode. Outside of the quest of achieving performance however, the usage of function pointers is not recommended.","title":"Function Pointers"},{"location":"FunctionPointers/#compromises-with-function-pointers","text":"Static functions only. No compile-time checking (no compile error if your function doesn't match defined pointer). No marshalling. Do it yourself. e.g. Marshal.StringToHGlobalAnsi and Marshal.FreeHGlobal for ANSI strings. No pointer types/ref/out (limitation of generics). You should use struct wrappers like Reloaded.Memory 's BlittablePointer . Then in your actual UnmanagedCallersOnly function declaration use raw pointers. There is an implicit conversion for BlittablePointer . Documentation: Cannot document parameter types outside of including the info directly in the struct description.","title":"Compromises with Function Pointers"},{"location":"FunctionPointers/#defining-functions","text":"As C# currently doesn't support named function pointers, we have to improvise a bit. In order to define a structure, you should define a struct with a single field of type FuncPtr . The generic type arguments to the FuncPtr are the arguments to your function pointer and the return type. // Parameter 1 is `int` // Parameter 2 is `int` // Return type is `int` [Function(CallingConventions.Cdecl)] public struct CalculatorFunction { public FuncPtr < int , int , int > Value ; } You should then be able to use ( CalculatorFunction ) in place of the regular delegate in all common APIs. Note: If no value is returned, consider using Reloaded.Hooks.Definitions.Structs.Void as the return parameter to help readability.","title":"Defining Functions"},{"location":"FunctionPointers/#calling-functions","text":"Calling functions is the same as with delegates, simply use the Invoke function of the pointer inside your struct. // Alias can be set at the top of the .cs file. private CalculatorFunction _addFunctionPointer ; void makeFunctionPointer () { var addFuncPointer = ReloadedHooks . CreateWrapper < CalculatorFunction >(( long ) _nativeCalculator . Add , out var _ ); var three = addFuncPointer . Value . Invoke ( 1 , 2 ); } Note: There are overloads for common calling conventions InvokeStdcall , InvokeCdecl and InvokeThiscall . Invoke is equivalent to InvokeStdcall .","title":"Calling Functions"},{"location":"FunctionPointers/#hooking-functions","text":"Hooking functions using poitners requires .NET 5; due to the necessity of using the UnmanagedCallersOnly attribute. /* Hook object. */ private static IHook < CalculatorFunction > _addHook ; // Reloaded.Hooks assumes function pointners are `Stdcall` on Windows (.NET default). // You should therefore use `CallConvStdcall` with your hook functions and use // Invoke/InvokeStdcall for calling the original function. [UnmanagedCallersOnly(CallConvs = new[] { typeof ( CallConvStdcall ) })] static int AddHookFunction ( int a , int b ) => _addHook . OriginalFunction . Value . Invoke ( a , b ) + 1 ; public unsafe void HookAdd () { _addHook = ReloadedHooks . Instance . CreateHook < CalculatorFunction >(( delegate * unmanaged [ Stdcall ]< int , int , int >)& AddHookFunction , ( long ) _nativeCalculator . Add ). Activate (); } For your UnmanagedCallersOnly function please use raw pointers in places of BlittablePointer (where applicable). There is an implicit conversion between the two so no manual conversions will be necessary when calling the original function again. There is currently an issue in the runtime where generics aren't properly checked for blittability with UnmanagedCallersOnly .","title":"Hooking Functions"},{"location":"FunctionPointers/#hooking-via-reflection","text":"Experimental : Thorough testing not yet conducted. /* Hook object. */ private static IHook < CalculatorFunction > _addHook ; [UnmanagedCallersOnly(CallConvs = new[] { typeof ( CallConvStdcall ) })] static int AddHookFunction ( int a , int b ) => _addHook . OriginalFunction . Value . Invoke ( a , b ) + 1 ; public unsafe void HookAdd () { _addHook = ReloadedHooks . Instance . CreateHook < CalculatorFunction >( typeof ( ThisClass ), nameof ( AddHookFunction ), ( long ) _nativeCalculator . Add ). Activate (); } Writing the cast to a function pointer can be tedious. As such, Reloaded.Hooks provides overloads which allow you to select a static function via reflection using the containing class and function name. Note: Local functions are not supported.","title":"Hooking via Reflection"},{"location":"GettingStarted/","text":"Getting Started Introduction In this article, will quickly-ish demonstrate simple usage allowing you to get started with Reloaded.Hooks. As this library, was originally created to deal with modifying and reverse engineering games; many of the examples in this documentation show snippets of real game functions as opposed to common APIs. That said, nothing changes when hooking arbitrary APIs. Adding Reloaded.Hooks to your project. Open/Create project in Visual Studio. Right-click your project within the Solution Explorer and select \u201cManage NuGet Packages\u2026\u201d. Search for \"Reloaded.Hooks\u201d. Install the package. Prologue: Definiting Functions Calling, hooking and performing other operations with native functions with Reloaded.Hooks is performed through the use of delegate declarations. Reloaded.Hooks' main library is able to create individual delegate instances given supplied function addresses in memory - allowing you to use native functions as if they were your own. Defining Reloaded-Compatible Delegates Defining delegates to call native functions under Reloaded.Hooks is performed just like defining regular delegates with only one catch. You must inform Reloaded.Hooks of the kind of function you are going to call with the use of Reloaded's own FunctionAttribute . There are two FunctionAttribute (s), namely X86.FunctionAttribute and X64.FunctionAttribute for x86 and x64 respectively. Depending on your project you may wish to apply one, the other or both. Note: Examples bwlow have been lifted from real pieces of source code. Example: Native CDECL Function /* RenderWare Graphics | Function that is step one to widescreen hacks in RenderWare games. */ [Function(CallingConventions.Cdecl)] public delegate void RwCameraSetViewWindow ( ref RWCamera RwCamera , ref RWView view ); Example: Function with registers as parameters Info In the real world, compilers will often optimise function calls to optimise for performance. This will often lead to the function using non-standard conventions, such e.g. accepting parameters via registers where normally the stack should be used. This is more common in x86 (32-bit) applications rather than x64 applications. Reloaded.Hooks allows for mapping parameters to given registers. /// <summary> /// Reads a ANM/HAnim stream from a .ONE archive. Returns address of a decompressed ANM file. /// </summary> /// <param name=\"fileIndex\">[EAX] The index of the file inside the .ONE archive (starting with 2)</param> /// <param name=\"addressToDecompressTo\">[ECX] The address to which the file inside the ONE archive will be decompressed to.</param> /// <param name=\"thisPointer\">\"This\" pointer for the ONEFILE class instance.</param> /// <returns>The address containing the read in ANM (RenderWare Hierarchical Animation) stream.</returns> [Function(new[] { Register . eax , Register . ecx }, Register . eax , StackCleanup . Callee )] public delegate int OneFileLoadHAnimation ( int fileIndex , void * addressToDecompressTo , ref ONEFILE thisPointer ); /* Lifted from a disassembly of Sonic Heroes */ This was an example of a custom function with the following properties: Two parameters (left to right) in registers EAX and ECX . Return register of EAX . \"Callee\" stack cleanup, i.e. the stack pointer is reset at the end of the function either via ret X (XXX Stdcall) or add esp, X . Those with some experience in reverse engineering might know that the popular IDA decompiler would identify such function as userpurge . For custom functions, under the hood Reloaded.Hooks creates wrappers that automatically convert between calling conventions such as the special one above that uses registers. These wrappers are actually what will be called behind the scenes as you call/hook your native functions, doing all the difficult work for you \u2764. Deciphering the Function Signature Info Some disassemblers may contain useful information about how the function is called. Below is guidance on deciphering the function signatures in some common disassemblers. Please note that disassemblers are not perfect; they can and will sometimes make mistakes. IDA Pro (Decompiler): // Example void * __userpurge OneFileLoadHAnimation @ < eax >( RwUInt32 type @ < eax >, void * dest @ < ecx >, ONEFILE * this ) // Breakdown FUNCTION_NAME @ < eax > in function name specifies return register is EAX . type @ < eax > specifies the ` type ` argument is passed via EAX register . dest @ < ecx > specifies the ` dest ` argument is passed via ECX register . remaining parameters are passed via stack . // Extra Info (IDA Specific) _userpurge == ' Callee ' Stack Cleanup _usercall == ' Caller ' Stack Cleanup Ghidra: Right click function name and click Edit Function . Inside the dialog, you will find the following: Note: Ghidra did not disassemble this correctly; I manually fixed this function for this example. Binary Ninja: This one is pretty self explanatory. // Example void * __stdcall OneFileLoadHAnimation ( int32_t arg1 @ eax , char * arg2 @ ecx , char * arg3 ) General: Some disassemblers might not provide information on return registers and/or stack cleanup because they are implied by the given convention (such as __stdcall ). Consider using the following presets in Reloaded.Hooks to determine these settings. X86 Calling Conventions (Presets) X64 Calling Conventions (Presets) Important Note About the API This is just a quick note before we introduce any direct code examples. To make things convenient, high level functions for all the features of the library are available within the ReloadedHooks class ( Reloaded.Hooks.ReloadedHooks ). These automatically detect if the current process is x86/x64 and use the appropriate underlying API. Please assume any usage of ReloadedHooks is an instance of Reloaded.Hooks.ReloadedHooks , which you can get easily via ReloadedHooks.Instance . Calling Functions In order to create an instance of your own custom delegate from a supplied function pointer, ReloadedHooks.CreateWrapper function is used. These will return you an instance of your requested function at address which you can call like a native function. // Based on the delegate above. var rwCameraSetViewWindow = ReloadedHooks . CreateWrapper < RwCameraSetViewWindow >( 0 x0064AC80 ); // You may now call the delegate instance/native/game fuction like if it was your own. rwCameraSetViewWindow ( camera , view ); Regarding the other, more complex nonstandard function seen above that has been optimized out by the compiler - nothing changes. The process is exactly the same and saves you having to write what would otherwise be custom inline assembly in the C++ world. Lower level APIs: Reloaded.Hooks.X86.Wrapper Reloaded.Hooks.X64.Wrapper Hooking Functions The hooking of arbitrary functions in Reloaded can also be considered a simple walk in the park. Below is a simple example of how you could hook a Win32 API to print out all files being opened by the current program. Example: File Monitor /* You MUST store the returned hook to prevent the Garbage Collector from freeing your hook function (CreateFileAImpl). */ /* Fields */ private IHook < CreateFileA > _createFileAHook ; /* Constructor */ public SomeClass () { // Get Address of Windows API function. IntPtr kernel32Handle = LoadLibraryW ( \"kernel32\" ); IntPtr createFileAPointer = GetProcAddress ( kernel32Handle , \"CreateFileA\" ); _createFileAHook = ReloadedHooks . CreateHook < CreateFileA >( CreateFileAImpl , ( long ) createFileAPointer ). Activate (); } /* Hook Function */ /// <summary> /// Contains the implementation of the CreateFileA hook. /// Simply prints the file name to the console and calls + returns the original function. /// </summary> private static IntPtr CreateFileAImpl ( string filename , FileAccess access , FileShare share , IntPtr securityAttributes , FileMode creationDisposition , FileAttributes flagsAndAttributes , IntPtr templateFile ) { // If statement filters out non-files such as HID devices; if (! filename . StartsWith ( @\"\\\\?\\\" )) Bindings . PrintInfo ( $\"[CFA] Opening File {filename}\" ); // Calls the original function we hooked and returns its value. return _createFileAHook . OriginalFunction ( filename , access , share , securityAttributes , creationDisposition , flagsAndAttributes , templateFile ); } There is nothing extra you need to do. Reloaded.Hooks handles everything for you under the hood such as calculating hook lengths and handling register parameters for special functions. You will never have to do silly error prone stuff such as writing custom inline assembler by hand. Reloaded's hooking code is really, really powerful, even patching common forms of hooks created by other programs and libraries for maximum compatibility (you can hook hooks!). For example, you can easily hook DirectX 9's EndScene or Present without breaking the Steam Overlay; this is something people normally struggle with and write dirty hacks to get around. Lower level APIs: Reloaded.Hooks.Hook Marshalling Support As Reloaded.Hooks uses .NET delegates, for both hooking and calling function, there is support for extra features such as marshalling. Here is an example: /* Within native code this individual function would be expressed as \"int PlayADX(char* fileName)\", here thanks to marshalling we are able to simply specify it as a string. In this specific case, additionally, CharSet = CharSet.Ansi must be specified as the game from which this function originates from did not use the Unicode encoding that is default in C#. */ [Function(CallingConventions.Cdecl)] [ UnmanagedFunctionPointer ( CallingConvention . Cdecl , CharSet = CharSet . Ansi ) public delegate int PlayADX ( string fileName ); /* Sourced from a clean room disassembly of Sonic Heroes */ Pointers to .NET Functions No hacking adventure would be ever complete with pointers to our own functions. Reloaded.Hooks supports this and as you'd expect, making life very easy for you. You can even make pointers to C# functions with custom calling conventions; e.g. effectively create a fastcall method in C#. Support for this functionality is provided through the use of the CreateReverseWrapper function. This returns a class, which contains a property WrapperPointer that can be used to call the C# function from native code. /* You MUST store the returned ReverseWrapper to prevent the Garbage Collector from freeing your function (CSharpFastcallFunction). */ // Define an x86 fastcall function (via template). // Microsoft Fastcall passes first two parameters in registers ECX, EDX and returns value in EAX. [Function(CallingConventions.Fastcall)] public delegate void FastcallExample ( int a , int b , int c ); /* Fields */ private IReverseWrapper < FastcallExample > _reverseFunctionWrapper ; private FastcallExample _functionWrapper ; /* Main/Init Method */ void FastcallCSharpFunctionPointerTest () { // Create wrapper to make our \"C# fastcall\" function. _reverseFunctionWrapper = ReloadedHooks . CreateReverseWrapper < FastcallExample >( CSharpFastcallFunction ); // To prove our \"C# fastcall\" function works, let's just call it like a native function. _functionWrapper = ReloadedHooks . CreateWrapper < FastcallExample >(( long ) _reverseFunctionWrapper . WrapperPointer ); _functionWrapper ( 1 , 2 , 3 ); } /* Function Implementation */ /// <summary> /// When called through the address in reverseFunctionWrapper.Pointer, /// this function is now a \"fastcall\" function. /// </summary> /// <param name=\"a\">This number is passed via ECX register!</param> /// <param name=\"b\">This number is passed via EDX register!</param> /// <param name=\"c\">This number is on the stack.</param> private static void CSharpFastcallFunction ( int a , int b , int c ) { MessageBox . Show ( $\"{a + b + c}\" ); } Lower level APIs: Reloaded.Hooks.X86.ReverseWrapper Reloaded.Hooks.X64.ReverseWrapper In Assembly Code If you would like to call managed C# code from assembly code generated at run-time (such as AsmHook ), consider using the ReloadedHooksUtilities.GetAbsoluteCallMnemonics helper function to generate the appropriate x86/x64 call instruction. // SomeFunction is a Stdcall C# function accepting two integers. // _reverseWrapAddFunction is a `ReverseWrapper`, it is a class member. string [] function = { $\"use32\" , // Backup registers meant to be saved by caller. // Not always necessary but good practice to do so! $\"{Utilities.PushCdeclCallerSavedRegisters()}\" $\"push ecx\" , // Right Parameter $\"push edx\" , // Left Parameter $\"{Utilities.GetAbsoluteCallMnemonics(SomeFunction, out _reverseWrapAddFunction)}\" , // Restore backed up registers. $\"{Utilities.PopCdeclCallerSavedRegisters()}\" $\"ret\" }; // You should reference the ReverseWrapper (out parameter) as long as you plan on using the // native/ASM function. Failure to do so will cause issues after Garbage Collection occurs. The calling convention of your C# function is controlled by UnmanagedFunctionPointerAttribute for Delegates (default is StdCall ). While not always necessary*, it is good practice that you wrap your call with PushCdeclCallerSavedRegisters and PopCdeclCallerSavedRegisters respectively (for both Cdecl and Stdcall). For a more advanced example, consider looking at CSharpFromAssembly.cs from Reloaded.Hooks' test code. * This depends on context; if using an assembly hook, the original function might be doing the backup/restore for you already. If you are unsure, you should always backup and restore. Misc Performance Notes Reloaded has checks and 'hot paths' implemented to prevent creating unnecessary wrappers. For example, if you call CreateReverseWrapper<T> for a function marked Stdcall with FunctionAttribute and the target function is already Stdcall, no wrapper will be generated and the input pointer will be returned. You can reduce the overhead of transitions between native code and .NET by using Function Pointers (C#9).","title":"Getting Started"},{"location":"GettingStarted/#getting-started","text":"","title":"Getting Started"},{"location":"GettingStarted/#introduction","text":"In this article, will quickly-ish demonstrate simple usage allowing you to get started with Reloaded.Hooks. As this library, was originally created to deal with modifying and reverse engineering games; many of the examples in this documentation show snippets of real game functions as opposed to common APIs. That said, nothing changes when hooking arbitrary APIs.","title":"Introduction"},{"location":"GettingStarted/#adding-reloadedhooks-to-your-project","text":"Open/Create project in Visual Studio. Right-click your project within the Solution Explorer and select \u201cManage NuGet Packages\u2026\u201d. Search for \"Reloaded.Hooks\u201d. Install the package.","title":"Adding Reloaded.Hooks to your project."},{"location":"GettingStarted/#prologue-definiting-functions","text":"Calling, hooking and performing other operations with native functions with Reloaded.Hooks is performed through the use of delegate declarations. Reloaded.Hooks' main library is able to create individual delegate instances given supplied function addresses in memory - allowing you to use native functions as if they were your own.","title":"Prologue: Definiting Functions"},{"location":"GettingStarted/#defining-reloaded-compatible-delegates","text":"Defining delegates to call native functions under Reloaded.Hooks is performed just like defining regular delegates with only one catch. You must inform Reloaded.Hooks of the kind of function you are going to call with the use of Reloaded's own FunctionAttribute . There are two FunctionAttribute (s), namely X86.FunctionAttribute and X64.FunctionAttribute for x86 and x64 respectively. Depending on your project you may wish to apply one, the other or both. Note: Examples bwlow have been lifted from real pieces of source code.","title":"Defining Reloaded-Compatible Delegates"},{"location":"GettingStarted/#example-native-cdecl-function","text":"/* RenderWare Graphics | Function that is step one to widescreen hacks in RenderWare games. */ [Function(CallingConventions.Cdecl)] public delegate void RwCameraSetViewWindow ( ref RWCamera RwCamera , ref RWView view );","title":"Example: Native CDECL Function"},{"location":"GettingStarted/#example-function-with-registers-as-parameters","text":"Info In the real world, compilers will often optimise function calls to optimise for performance. This will often lead to the function using non-standard conventions, such e.g. accepting parameters via registers where normally the stack should be used. This is more common in x86 (32-bit) applications rather than x64 applications. Reloaded.Hooks allows for mapping parameters to given registers. /// <summary> /// Reads a ANM/HAnim stream from a .ONE archive. Returns address of a decompressed ANM file. /// </summary> /// <param name=\"fileIndex\">[EAX] The index of the file inside the .ONE archive (starting with 2)</param> /// <param name=\"addressToDecompressTo\">[ECX] The address to which the file inside the ONE archive will be decompressed to.</param> /// <param name=\"thisPointer\">\"This\" pointer for the ONEFILE class instance.</param> /// <returns>The address containing the read in ANM (RenderWare Hierarchical Animation) stream.</returns> [Function(new[] { Register . eax , Register . ecx }, Register . eax , StackCleanup . Callee )] public delegate int OneFileLoadHAnimation ( int fileIndex , void * addressToDecompressTo , ref ONEFILE thisPointer ); /* Lifted from a disassembly of Sonic Heroes */ This was an example of a custom function with the following properties: Two parameters (left to right) in registers EAX and ECX . Return register of EAX . \"Callee\" stack cleanup, i.e. the stack pointer is reset at the end of the function either via ret X (XXX Stdcall) or add esp, X . Those with some experience in reverse engineering might know that the popular IDA decompiler would identify such function as userpurge . For custom functions, under the hood Reloaded.Hooks creates wrappers that automatically convert between calling conventions such as the special one above that uses registers. These wrappers are actually what will be called behind the scenes as you call/hook your native functions, doing all the difficult work for you \u2764.","title":"Example: Function with registers as parameters"},{"location":"GettingStarted/#deciphering-the-function-signature","text":"Info Some disassemblers may contain useful information about how the function is called. Below is guidance on deciphering the function signatures in some common disassemblers. Please note that disassemblers are not perfect; they can and will sometimes make mistakes. IDA Pro (Decompiler): // Example void * __userpurge OneFileLoadHAnimation @ < eax >( RwUInt32 type @ < eax >, void * dest @ < ecx >, ONEFILE * this ) // Breakdown FUNCTION_NAME @ < eax > in function name specifies return register is EAX . type @ < eax > specifies the ` type ` argument is passed via EAX register . dest @ < ecx > specifies the ` dest ` argument is passed via ECX register . remaining parameters are passed via stack . // Extra Info (IDA Specific) _userpurge == ' Callee ' Stack Cleanup _usercall == ' Caller ' Stack Cleanup Ghidra: Right click function name and click Edit Function . Inside the dialog, you will find the following: Note: Ghidra did not disassemble this correctly; I manually fixed this function for this example. Binary Ninja: This one is pretty self explanatory. // Example void * __stdcall OneFileLoadHAnimation ( int32_t arg1 @ eax , char * arg2 @ ecx , char * arg3 ) General: Some disassemblers might not provide information on return registers and/or stack cleanup because they are implied by the given convention (such as __stdcall ). Consider using the following presets in Reloaded.Hooks to determine these settings. X86 Calling Conventions (Presets) X64 Calling Conventions (Presets)","title":"Deciphering the Function Signature"},{"location":"GettingStarted/#important-note-about-the-api","text":"This is just a quick note before we introduce any direct code examples. To make things convenient, high level functions for all the features of the library are available within the ReloadedHooks class ( Reloaded.Hooks.ReloadedHooks ). These automatically detect if the current process is x86/x64 and use the appropriate underlying API. Please assume any usage of ReloadedHooks is an instance of Reloaded.Hooks.ReloadedHooks , which you can get easily via ReloadedHooks.Instance .","title":"Important Note About the API"},{"location":"GettingStarted/#calling-functions","text":"In order to create an instance of your own custom delegate from a supplied function pointer, ReloadedHooks.CreateWrapper function is used. These will return you an instance of your requested function at address which you can call like a native function. // Based on the delegate above. var rwCameraSetViewWindow = ReloadedHooks . CreateWrapper < RwCameraSetViewWindow >( 0 x0064AC80 ); // You may now call the delegate instance/native/game fuction like if it was your own. rwCameraSetViewWindow ( camera , view ); Regarding the other, more complex nonstandard function seen above that has been optimized out by the compiler - nothing changes. The process is exactly the same and saves you having to write what would otherwise be custom inline assembly in the C++ world. Lower level APIs: Reloaded.Hooks.X86.Wrapper Reloaded.Hooks.X64.Wrapper","title":"Calling Functions"},{"location":"GettingStarted/#hooking-functions","text":"The hooking of arbitrary functions in Reloaded can also be considered a simple walk in the park. Below is a simple example of how you could hook a Win32 API to print out all files being opened by the current program.","title":"Hooking Functions"},{"location":"GettingStarted/#example-file-monitor","text":"/* You MUST store the returned hook to prevent the Garbage Collector from freeing your hook function (CreateFileAImpl). */ /* Fields */ private IHook < CreateFileA > _createFileAHook ; /* Constructor */ public SomeClass () { // Get Address of Windows API function. IntPtr kernel32Handle = LoadLibraryW ( \"kernel32\" ); IntPtr createFileAPointer = GetProcAddress ( kernel32Handle , \"CreateFileA\" ); _createFileAHook = ReloadedHooks . CreateHook < CreateFileA >( CreateFileAImpl , ( long ) createFileAPointer ). Activate (); } /* Hook Function */ /// <summary> /// Contains the implementation of the CreateFileA hook. /// Simply prints the file name to the console and calls + returns the original function. /// </summary> private static IntPtr CreateFileAImpl ( string filename , FileAccess access , FileShare share , IntPtr securityAttributes , FileMode creationDisposition , FileAttributes flagsAndAttributes , IntPtr templateFile ) { // If statement filters out non-files such as HID devices; if (! filename . StartsWith ( @\"\\\\?\\\" )) Bindings . PrintInfo ( $\"[CFA] Opening File {filename}\" ); // Calls the original function we hooked and returns its value. return _createFileAHook . OriginalFunction ( filename , access , share , securityAttributes , creationDisposition , flagsAndAttributes , templateFile ); } There is nothing extra you need to do. Reloaded.Hooks handles everything for you under the hood such as calculating hook lengths and handling register parameters for special functions. You will never have to do silly error prone stuff such as writing custom inline assembler by hand. Reloaded's hooking code is really, really powerful, even patching common forms of hooks created by other programs and libraries for maximum compatibility (you can hook hooks!). For example, you can easily hook DirectX 9's EndScene or Present without breaking the Steam Overlay; this is something people normally struggle with and write dirty hacks to get around. Lower level APIs: Reloaded.Hooks.Hook","title":"Example: File Monitor"},{"location":"GettingStarted/#marshalling-support","text":"As Reloaded.Hooks uses .NET delegates, for both hooking and calling function, there is support for extra features such as marshalling. Here is an example: /* Within native code this individual function would be expressed as \"int PlayADX(char* fileName)\", here thanks to marshalling we are able to simply specify it as a string. In this specific case, additionally, CharSet = CharSet.Ansi must be specified as the game from which this function originates from did not use the Unicode encoding that is default in C#. */ [Function(CallingConventions.Cdecl)] [ UnmanagedFunctionPointer ( CallingConvention . Cdecl , CharSet = CharSet . Ansi ) public delegate int PlayADX ( string fileName ); /* Sourced from a clean room disassembly of Sonic Heroes */","title":"Marshalling Support"},{"location":"GettingStarted/#pointers-to-net-functions","text":"No hacking adventure would be ever complete with pointers to our own functions. Reloaded.Hooks supports this and as you'd expect, making life very easy for you. You can even make pointers to C# functions with custom calling conventions; e.g. effectively create a fastcall method in C#. Support for this functionality is provided through the use of the CreateReverseWrapper function. This returns a class, which contains a property WrapperPointer that can be used to call the C# function from native code. /* You MUST store the returned ReverseWrapper to prevent the Garbage Collector from freeing your function (CSharpFastcallFunction). */ // Define an x86 fastcall function (via template). // Microsoft Fastcall passes first two parameters in registers ECX, EDX and returns value in EAX. [Function(CallingConventions.Fastcall)] public delegate void FastcallExample ( int a , int b , int c ); /* Fields */ private IReverseWrapper < FastcallExample > _reverseFunctionWrapper ; private FastcallExample _functionWrapper ; /* Main/Init Method */ void FastcallCSharpFunctionPointerTest () { // Create wrapper to make our \"C# fastcall\" function. _reverseFunctionWrapper = ReloadedHooks . CreateReverseWrapper < FastcallExample >( CSharpFastcallFunction ); // To prove our \"C# fastcall\" function works, let's just call it like a native function. _functionWrapper = ReloadedHooks . CreateWrapper < FastcallExample >(( long ) _reverseFunctionWrapper . WrapperPointer ); _functionWrapper ( 1 , 2 , 3 ); } /* Function Implementation */ /// <summary> /// When called through the address in reverseFunctionWrapper.Pointer, /// this function is now a \"fastcall\" function. /// </summary> /// <param name=\"a\">This number is passed via ECX register!</param> /// <param name=\"b\">This number is passed via EDX register!</param> /// <param name=\"c\">This number is on the stack.</param> private static void CSharpFastcallFunction ( int a , int b , int c ) { MessageBox . Show ( $\"{a + b + c}\" ); } Lower level APIs: Reloaded.Hooks.X86.ReverseWrapper Reloaded.Hooks.X64.ReverseWrapper","title":"Pointers to .NET Functions"},{"location":"GettingStarted/#in-assembly-code","text":"If you would like to call managed C# code from assembly code generated at run-time (such as AsmHook ), consider using the ReloadedHooksUtilities.GetAbsoluteCallMnemonics helper function to generate the appropriate x86/x64 call instruction. // SomeFunction is a Stdcall C# function accepting two integers. // _reverseWrapAddFunction is a `ReverseWrapper`, it is a class member. string [] function = { $\"use32\" , // Backup registers meant to be saved by caller. // Not always necessary but good practice to do so! $\"{Utilities.PushCdeclCallerSavedRegisters()}\" $\"push ecx\" , // Right Parameter $\"push edx\" , // Left Parameter $\"{Utilities.GetAbsoluteCallMnemonics(SomeFunction, out _reverseWrapAddFunction)}\" , // Restore backed up registers. $\"{Utilities.PopCdeclCallerSavedRegisters()}\" $\"ret\" }; // You should reference the ReverseWrapper (out parameter) as long as you plan on using the // native/ASM function. Failure to do so will cause issues after Garbage Collection occurs. The calling convention of your C# function is controlled by UnmanagedFunctionPointerAttribute for Delegates (default is StdCall ). While not always necessary*, it is good practice that you wrap your call with PushCdeclCallerSavedRegisters and PopCdeclCallerSavedRegisters respectively (for both Cdecl and Stdcall). For a more advanced example, consider looking at CSharpFromAssembly.cs from Reloaded.Hooks' test code. * This depends on context; if using an assembly hook, the original function might be doing the backup/restore for you already. If you are unsure, you should always backup and restore.","title":"In Assembly Code"},{"location":"GettingStarted/#misc-performance-notes","text":"Reloaded has checks and 'hot paths' implemented to prevent creating unnecessary wrappers. For example, if you call CreateReverseWrapper<T> for a function marked Stdcall with FunctionAttribute and the target function is already Stdcall, no wrapper will be generated and the input pointer will be returned. You can reduce the overhead of transitions between native code and .NET by using Function Pointers (C#9).","title":"Misc Performance Notes"},{"location":"Utilities/","text":"Utilities This section is a quick reference/directory to the various utility functions and classes available. ReloadedHooks & IReloadedHooks ReloadedHooks is a one stop shop for this library, encompassing all main and commonly used functionality inside of a single class. For example: _reloadedHooks . CreateWrapper < NtCreateFile >( ntCreateFile , out _ ); Would be functionally equivalent to: new X86.Wrapper.Create<TFunction>(function, out _); or new X64.Wrapper.Create<TFunction>(function, out _); depending on architecture of current process. If you are already familiar with Reloaded.Hooks as a library, everything inside IReloadedHooks should be self explanatory. Function Function<T> is an API that wraps a native function given a pointer and instance of IReloadedHooks . For example, creating an instance of the class: // _calculator.Add is a function address // _hooks is an instance of ReloadedHooks _addFunction = new Function < Calculator . AddFunction >(( long ) _calculator . Add , _hooks ); Allows you to more easily use common operations of the library. // Hook Function _addHook = _addFunction . Hook ( Hookfunction ). Activate (); // Call Function _addFunction . GetWrapper ()( x , y ); The intended use of this class is to simplify usage when building APIs that can interface with a given process. For example: APIs that allow for hacking specific games. Remarks: The return value of GetWrapper() is cached, repeated calls will return the same results. Calling Function Pointers Should you ever find yourself needing to call functions that are pointed to by a pointer whose value constantly changes, Reloaded.Hooks provides you with a simple utility class to help you alleviate the pain of constantly changing function addresses. The utility class is simply named FunctionPtr and can be found at Reloaded.Hooks.Tools respectively - the usage is simple. Here is a small sample example: // 0x123456 is the address of a pointer which points to a function of type MyCustomDelegate // MyCustomDelegate is a delegate marked with FunctionAttribute and UnmanagedFunctionPointerAttribute. FunctionPtr < MyCustomDelegate > functionPtr = new FunctionPtr < MyCustomDelegate >( 0 x123456 ); // Gets the address of our function (dereferences pointer). var functionAddress = functionPtr . GetFunctionAddress ( 0 ); // Index: This class supports arrays of pointers. // Gets the delegate to use for calling the native function and calls the function. // You should this every time you intend to use the function pointer to call function. var myCustomFunction = functionPtr . GetDelegate (); myCustomFunction ( 1000 );","title":"Extras & Utilities"},{"location":"Utilities/#utilities","text":"This section is a quick reference/directory to the various utility functions and classes available.","title":"Utilities"},{"location":"Utilities/#reloadedhooks-ireloadedhooks","text":"ReloadedHooks is a one stop shop for this library, encompassing all main and commonly used functionality inside of a single class. For example: _reloadedHooks . CreateWrapper < NtCreateFile >( ntCreateFile , out _ ); Would be functionally equivalent to: new X86.Wrapper.Create<TFunction>(function, out _); or new X64.Wrapper.Create<TFunction>(function, out _); depending on architecture of current process. If you are already familiar with Reloaded.Hooks as a library, everything inside IReloadedHooks should be self explanatory.","title":"ReloadedHooks &amp; IReloadedHooks"},{"location":"Utilities/#function","text":"Function<T> is an API that wraps a native function given a pointer and instance of IReloadedHooks . For example, creating an instance of the class: // _calculator.Add is a function address // _hooks is an instance of ReloadedHooks _addFunction = new Function < Calculator . AddFunction >(( long ) _calculator . Add , _hooks ); Allows you to more easily use common operations of the library. // Hook Function _addHook = _addFunction . Hook ( Hookfunction ). Activate (); // Call Function _addFunction . GetWrapper ()( x , y ); The intended use of this class is to simplify usage when building APIs that can interface with a given process. For example: APIs that allow for hacking specific games. Remarks: The return value of GetWrapper() is cached, repeated calls will return the same results.","title":"Function"},{"location":"Utilities/#calling-function-pointers","text":"Should you ever find yourself needing to call functions that are pointed to by a pointer whose value constantly changes, Reloaded.Hooks provides you with a simple utility class to help you alleviate the pain of constantly changing function addresses. The utility class is simply named FunctionPtr and can be found at Reloaded.Hooks.Tools respectively - the usage is simple. Here is a small sample example: // 0x123456 is the address of a pointer which points to a function of type MyCustomDelegate // MyCustomDelegate is a delegate marked with FunctionAttribute and UnmanagedFunctionPointerAttribute. FunctionPtr < MyCustomDelegate > functionPtr = new FunctionPtr < MyCustomDelegate >( 0 x123456 ); // Gets the address of our function (dereferences pointer). var functionAddress = functionPtr . GetFunctionAddress ( 0 ); // Index: This class supports arrays of pointers. // Gets the delegate to use for calling the native function and calls the function. // You should this every time you intend to use the function pointer to call function. var myCustomFunction = functionPtr . GetDelegate (); myCustomFunction ( 1000 );","title":"Calling Function Pointers"}]}